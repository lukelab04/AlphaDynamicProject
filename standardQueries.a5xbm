'TIP: You can encrypt this file when it is saved, or password protect it, by adding a special comment to the first line of the file (with no leading spaces).
'To encrypt the file, set the comment on the first line to: 'ENCRYPTED
'To password protect the file (which will also encrypt it), set the comment on the first line to: 'PASSWORD:your_password_phrase
'To create a compiled AEX library (when this project is published), add the comment 'COMPILEAEX at the START of a line in the code.

' Input: [e.filters] like {"columnName": name, columnVal: val, connector: 'OR' | 'AND', op: '=', '!=', etc}
' Input: e.configName
' Input: e.pageOptions like {pageSize: n, getPage: n} or nothing
function querySqlWithFilters (e as p) as c 
	dim configInterface as p
	dim config as c
	dim configJson as extension::json
	configInterface = require("listConfigInterface")
	config = configInterface.requestConfig(e)
	configJson.setJson(config)
	
	if configJson.hasProperty("err") then 
		querySqlWithFilters = configJson 
		end 
	end if
	
	dim pageOptions as a
	dim filters as extension::Json
	
	if e.data("pageOptions") <> "" then 
		pageOptions = e.pageOptions
	else 
		pageOptions = null_value()
	end if 
	
	filters.setJson(e.filters)
	
	configJson = configJson.getProperty("ok")
	' If the config's datasource has the 'table' property, then 
	' we construct the SQL query given information from mappings & filters.
	if configJson.getProperty("dataSource").hasProperty("table") then
		dim columns[0] as a
		for i = 0 to configJson.getProperty("mappings").getLength() - 1
			dim index as n
			index = columns.append(1)
			columns[index] = configJson.getProperty("mappings").getIndexed(i).getProperty("columnName")
		next
		
		querySqlWithFilters = getTableData(configJson.getProperty("dataSource").getProperty("table"), columns, pageOptions, filters)
	else
		dim sql as c 
		sql = configJson.getProperty("dataSource").getProperty("sql")
		dim existingFilters as extension::json 
		existingFilters = configJson.getProperty("dataSource").getProperty("filters")
		for i = 0 to filters.getLength() - 1
			existingFilters.push(filters.getIndexed(i))
		next
		
		
		querySqlWithFilters = getTableDataFromSql(sql, pageOptions, existingFilters)
	end if
	
end function

function getTableDataFromSql (sql as c, pageOptions as a, filters as extension::json) as c 
	'DIM an Xbasic AlphaDAO connection object
	dim cn as sql::connection
	dim flag as l
	dim args as sql::arguments
	''open the connection object to connect to the Database
	flag = cn_open(cn,"::Name::conn")
	
	dim filterStr as c
	filterStr = buildConstraint(filters, args, cn)
	
	if len(filterStr) <> 0 then 
		sql = sql + " WHERE " + filterStr
	end if
	
	dim result as p 
	result = runSqlFetch(cn, sql, args, pageOptions)
	
	if result.data("err") then 
		getTableDataFromSql = "{\"err\": " + json_generate(result.err) + "}"
	else 
		getTableDataFromSql = "{\"ok\": " + result.ok + ", \"count\": " + 0 + "}"
	end if
	
	'Clean up by freeing the resultset and then closing the database
	cn.freeresult()
	cn.close()
end function

function getTableData (tableName as c, columns as p, pageOptions as a, filters as extension::json) as c
	
	'DIM an Xbasic AlphaDAO connection object
	dim cn as sql::connection
	dim flag as l
	''open the connection object to connect to the Database
	flag = cn_open(cn,"::Name::conn")
	
	if columns.size == 0 then 
		getTableData = "{\"ok\": []}"
		end 
	end if
	
	dim args as sql::arguments
	dim filterStr as c
	filterStr = buildConstraint(filters, args, cn)
	

	dim sql as c
	dim selectPart as c 
	dim fromPart as c
	dim wherePart as c
	dim rowStart as n
	dim getRows as n
	
	selectPart = ""
	for each col in columns
		selectPart = selectPart + "[" + col.value + "],"
	next
	
	if selectPart == "" then 
		selectPart = " * "
	end if
	
	if right(selectPart, 1) == "," then 
		selectPart = substr(selectPart, 1, len(selectPart) - 1)
	end if
	
	fromPart = " [" + tableName + "]"
	
	if len(filterStr) <> 0 then 
		wherePart = " " + filterStr
	else 
		wherePart = " 1 = 1 "
	end if
	
	sql = "SELECT " + selectPart + " FROM " + fromPart + " WHERE " + wherePart
	
	dim data as p 
	data = runSqlFetch(cn, sql, args, pageOptions)
	
	if data.data("err") <> "" then 
		getTableData = "{\"err\": " + json_generate(data.err) + "}"
		end 
	end if 
	
	dim count as n
	count = sql_count(cn, tableName, "*", wherePart, args);
	getTableData = "{\"ok\": " + data.ok + ", \"count\": " + count + "}"
	
	'Clean up by freeing the resultset and then closing the database
	cn.freeresult()
	cn.close()
	
end function

' Return an object like { ok: Json } | { err: errMsg }
function runSqlFetch as p (cn as sql::connection, sql as c, args as sql::Arguments, pageOptions as a)
	dim result as p 
	
	if pageOptions == null_value() then 
		rowStart = 1
		getRows = -1
	else
		dim pageOptions as p
		rowStart = 1 + (pageOptions.getProperty("pageSize") * (pageOptions.getProperty("getPage") - 1))
		getRows = pageOptions.getProperty("pageSize")
	end if
	
	'turn portable SQL on. (for more information on portable sql search in help (https://www.alphasoftware.com/documentation)
	cn.PortableSQLEnabled = .t.
	'execute the SQL - pass in the sql::arguments object
	flag = cn.execute(sql,args)
	if flag = .f. then 
		'an error occurred - get the error message from cn.callresult.text 
		'report the error, close the database and then end the script
		dim errortext as c 
		errortext = js_escape(cn.callresult.text)
		result.err = errortext
		runSqlFetch = result
		cn.close()
		end
	end if
	'DIM a SQL::Resultset object
	dim rs as sql::resultset
	rs = cn.resultset
	dim cr as sql::CallResult 
	cr = cn.CallResult
	
	'get the JSON from the query
	dim json as c 
	json = rs.toJSON(getRows, rowStart)
	result.ok = json 
	runSqlFetch = result
end function

' Input: [e.filters] like {"columnName": name, columnVal: val, connector: 'OR' | 'AND', op: '=', '!=', etc}
function countRowsWithFilter(e as p) as c
		
	'DIM an Xbasic AlphaDAO connection object
	dim cn as sql::connection
	dim flag as l
	''open the connection object to connect to the Database
	flag = cn_open(cn,"::Name::conn")
	
	dim args as sql::arguments
	dim filtersJson as extension::json 
	filtersJson.setJson(e.filters)
	dim filterStr as c
	filterStr = buildConstraint(filtersJson, args, cn)
	
	dim configInterface as p
	dim config as c
	dim configJson as extension::json
	configInterface = require("listConfigInterface")
	config = configInterface.requestConfig(e)
	configJson.setJson(config)
	
	if configJson.hasProperty("err") then 
		countRowsWithFilter = "{dialog.object}.stateInfo.numRowsAvailable = " + 0 + ";"
		end 
	end if
	
	configJson = configJson.getProperty("ok")

	dim wherePart as c
	
	if len(filterStr) <> 0 then 
		wherePart = " " + filterStr
	else 
		wherePart = " 1 = 1 "
	end if
	
	dim count as n
	count = sql_count(cn, configJson.getProperty("dataSource").getProperty("table"), "*", wherePart, args);
	
	if count < 0 then 
		count = 0
	end if 
	
	countRowsWithFilter = "{dialog.object}.stateInfo.numRowsAvailable = " + count + ";"
end function

function buildConstraint(filters as extension::json, args as sql::arguments, connection as sql::connection) as c	
	dim args as sql::arguments
	dim filterStr as c
	filterStr = ""

	if filters.getLength() == 0 then 
		filterStr = "";
	else
		dim argCounter as n
		dim filter as p
		argCounter = 0
		for i = 0 to filters.getLength() - 1
			filter = filters.getIndexed(i)
			if .not. (filter.hasProperty("op")) .or. (.not. isSafeOp(filter.getProperty("op"))) then 
				filter.setProperty("op", "=")
			end if 
			
			if .not. (filter.hasProperty("connector")) .or. (.not. isSafeConnector(filter.getProperty("connector"))) then 
				filter.setProperty("connector", "AND")
			end if
			
			if .not. (filter.hasProperty("type")) then 
				filter.setProperty("type", "c")
			end if
			filterStr = filterStr + "[" + connection.generateNativeColumnName(filter.getProperty("columnName")) + "] " + filter.getProperty("op") + " :argNum" + argCounter + " " + filter.getProperty("connector") + " "
			args.add("argNum" + argCounter, convert_type(filter.getProperty("columnVal"), filter.getProperty("type")))
			argCounter = argCounter + 1
		next
	end if
	
	if len(filterStr) != 0 then
		' Get rid of AND or OR
		filterStr = substr(filterStr, 1, len(filterStr) - 4)
	end if
	buildConstraint = filterStr
end function

function isSafeConnector as l (conn as c) 
	isSafeConnector = (conn == "AND" .or. conn == "OR")
end function

function isSafeOp as l (op as c)
	isSafeOp = (op == "=") .or. (op == "<>") .or. (op == "<") .or. (op == "<=") .or. (op == ">") .or. (op == ">=") .or. (op == "LIKE")
end function 

' Input: Table Name
' Input: dirty (from 'harvestList')
function updateTableData (e as p) as c
	
	dim schemaInfo as p
	dim info as c
	dim schema as p
	schemaInfo = require("schemaInfo")
	info = schemaInfo.getConnectionSchemaJSON("conn", e.tableName)
	schema = json_parse(info)
	
	dim dirty as p
	dirty = json_parse(e.dirty)
	
	'DIM an Xbasic AlphaDAO connection object
	dim cn as sql::connection
	dim flag as l
	''open the connection object to connect to the Database
	flag = cn_open(cn,"::Name::conn")
	
	dim results as c
	results = ""
	
	for each item in dirty
		
		dim shouldDelete as l
		dim shouldUpdate as l
		dim shouldInsert as l
		
		if prop_valid(item.value, "_isDeleted") then 
			shouldDelete = item.value._isDeleted
		else if prop_valid(item.value, "_isNewRow") then 
			shouldInsert = item.value._isNewRow
		end if 
		
		if shouldDelete == .f. .and. shouldInsert == .f. then 
			shouldUpdate = .t.
		end if
		
		
		if shouldDelete then 
			results = results + runDeleteQuery(e, schema, item, cn)
		else if shouldUpdate then 
			results = results + runUpdateQuery(e, schema, item, cn)
		else if shouldInsert then
			results = results + runInsertQuery(e, schema, item, cn)
		end if
	next item
	
	updateTableData = results
	
end function

function runUpdateQuery as c (e as p, schema as p, item as p, cn as sql::connection)
	dim updateSql as c
	updateSql = "UPDATE [" + e.tableName + "] SET "
	dim args as sql::arguments
	
	' For each field, add an arg to the pile
	for each column in schema.jsonOutput.column
		if prop_valid(item.value, column.value.name) == .f. then 
			continue 
		end if
		
		if column.value.name == schema.primaryKey then 
			args.set(schema.primaryKey, convert_type(item.value.data(schema.primaryKey), column.value.alphaType))
			continue
		end if 
		
		args.set(column.value.name, convert_type(item.value.data(column.value.name), column.value.alphaType))
		updateSql = updateSql + "[" + column.value.name + "] = :" + column.value.name + ","

	next field
	
	if right(updateSql, 1) == "," then  
		updateSql = substr(updateSql, 1, len(updateSql) - 1)
	end if
	
	updateSql = updateSql + " WHERE [" + schema.primaryKey + "] = :" + schema.primaryKey
	
	'turn portable SQL on. (for more information on portable sql search in help (https://www.alphasoftware.com/documentation)
	cn.PortableSQLEnabled = .t.
	'execute the SQL - pass in the sql::arguments object
	flag = cn.execute(updateSql,args)
	if flag = .f. then 
		'an error occurred - get the error message from cn.callresult.text 
		'report the error, close the database and then end the script
		dim errortext as c 
		errortext = js_escape(cn.callresult.text)
		runUpdateQuery = "console.error('" +  errortext + "');"
		cn.close()
		end
	end if
	
	runUpdateQuery = ";"
end function

function runInsertQuery as c (e as p, schema as p, item as p, cn as sql::connection)
	dim insertSql as c
	insertSql = "INSERT INTO [" + e.tableName + "] ("
	dim args as sql::arguments
	
	dim valueSql as c
	valueSql = " VALUES ("
	
	for each column in schema.jsonOutput.column
		if prop_valid(item.value, column.value.name) == .f. then 
			continue 
		end if
		
		if column.value.name == schema.primaryKey then
			continue
		end if 
		
		args.set(column.value.name, convert_type(item.value.data(column.value.name), column.value.alphaType))
		insertSql = insertSql + "[" + column.value.name + "],"
		valueSql = valueSql + ":" + column.value.name + ","

	next field
	
	if right(insertSql, 1) == "," then  
		insertSql = substr(insertSql, 1, len(insertSql) - 1)
	end if
	
	if right(valueSql, 1) == "," then  
		valueSql = substr(valueSql, 1, len(valueSql) - 1)
	end if
	
	insertSql = insertSql + ")"
	valueSql = valueSql + ")"
	
	insertSql = insertSql + valueSql
	
	'turn portable SQL on. (for more information on portable sql search in help (https://www.alphasoftware.com/documentation)
	cn.PortableSQLEnabled = .t.
	'execute the SQL - pass in the sql::arguments object
	flag = cn.execute(insertSql,args)
	if flag = .f. then 
		'an error occurred - get the error message from cn.callresult.text 
		'report the error, close the database and then end the script
		dim errortext as c 
		errortext = js_escape(cn.callresult.text)
		runInsertQuery = "console.error('" +  errortext + "');"
		cn.close()
		end
	end if
	runInsertQuery = ";"
end function

function runDeleteQuery as c (e as p, schema as p, item as p, cn as sql::connection)
	dim deleteSql as c
	deleteSql = "DELETE FROM [" + e.tableName + "] WHERE [" + schema.primaryKey + "] = :" + schema.primaryKey
	
	dim args as sql::arguments 
	args.add(schema.primaryKey, item.value.data(schema.primaryKey))
	
	'turn portable SQL on. (for more information on portable sql search in help (https://www.alphasoftware.com/documentation)
	cn.PortableSQLEnabled = .t.
	'execute the SQL - pass in the sql::arguments object
	flag = cn.execute(deleteSql,args)
	if flag = .f. then 
		'an error occurred - get the error message from cn.callresult.text 
		'report the error, close the database and then end the script
		dim errortext as c 
		errortext = js_escape(cn.callresult.text)
		runDeleteQuery = "console.error('" +  errortext + "');"
		cn.close()
		end
	end if
	runDeleteQuery = ";"
end function


function performFetch as c (e as p)
	dim settings as p
	dim settings.method as c
	dim settings.host as c
	dim options as p
	dim urlData as p
	
	if e.options <> "undefined" then
		options = json_parse(e.options)
	else 
		options = json_parse("{}")
	end if
	
	urlData = a5_split_url(e.url)
	settings.host = urlData.server

	dim settings.page as c
	settings.page = urlData.path + urlData.page
	
	if urlData.query_string <> "" then 
		dim settings.query_string as c 
		settings.query_string = urlData.query_string
	end if
	
	
	if prop_valid(options, "method") then 
		settings.method = options.method
	else 
		settings.method = "GET"
	end if 
	
	dim apiKeys as p
	dim keysFilePath as c
	keysFilePath = "./apiKeys.json"
	apiKeys = json_parse(FILE.to_string(keysFilePath))
	
	if prop_valid(options, "headers") then
		dim settings.header as c
		settings.header = ""
		for each property in properties_enum(options.headers)
			dim val as c
			val = options.headers.data(property.value)
			if substr(val, 1, 7) == "__KEY__" then 
				val = apiKeys.data(substr(val, 8))
			end if
			
			settings.header = settings.header + property.value + ": " + val
		next
	end if
	
	if prop_valid(options, "body") then 
		dim settings.body as c
		settings.body = options.body
	end if
	
	dim result as P
	performFetch = json_generate(http_fetch(settings))
	
end function


exports.getTableData = getTableData
exports.updateTableData = updateTableData
exports.countRowsWithFilter = countRowsWithFilter
exports.performFetch = performFetch
exports.querySqlWithFilters = querySqlWithFilters

