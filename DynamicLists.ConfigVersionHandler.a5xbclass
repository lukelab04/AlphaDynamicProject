'TIP: You can encrypt this file when it is saved, or password protect it, by adding a special comment to the first line of the file (with no leading spaces).
'To encrypt the file, set the comment on the first line to: 'ENCRYPTED
'To password protect the file (which will also encrypt it), set the comment on the first line to: 'PASSWORD:your_password_phrase

'IMPORTANT - WEB APPLICATIONS: If you are using this class definition in Xbasic code in a web application, after you publish a new version of the class definition,
'you must call the loadclass() function at least once before you DIM an instance of the class. For example: loadClass("mynamespace::mySampleClass")

define class DynamicLists::ConfigVersionHandler
	dim read VERSIONS[0] as c = ["0.8.0", "0.8.1", "0.8.2", "0.8.3", "0.8.4", "0.8.5"]
	dim read protected write CURRENT_VERSION
	dim read protected write MADE_CHANGES as l
	
	function ConfigVersionHandler()
		CURRENT_VERSION = VERSIONS[VERSIONS.size()]
		MADE_CHANGES = .f.
	end function
	
	function handleConversion as extension::json (config as extension::json)
		MADE_CHANGES = .f.
		' No short circuiting operators, so we have to evaluate in the loop
		while .t.
			dim version as c
			if config.hasProperty("version") then 
				version = config.getProperty("version")
			else
				version = "unversioned"
			end if
			
			if version = CURRENT_VERSION then 
				exit while 
			end if
			
			select 
				case version = "unversioned"
					config = convertUnversioned(config)
				case version = "0.8.0"
					config = convert080to081(config)
				case version = "0.8.1"
					config = convert081to082(config)
				case version = "0.8.2"
					config = convert082to083(config)
				case version = "0.8.3"
					config = convert083to084(config)
				case version = "0.8.4"
					config = convert084to085(config)
			end select

		end while
		
		handleConversion = config
	end function

	function private convert084to085 as extension::json (config as extension::json)
		if config.hasProperty("multiSelect") then 
			MADE_CHANGES = .t.

			dim newRowOps as extension::json 
			newRowOps.setJson("{\"multiSelect\": " + if(config.getProperty("multiSelect"), "true", "false") + "}")

			config.setProperty("rowOptions", newRowOps)
		end if

		config.setProperty("version", "0.8.5")
		convert084to085 = config
	end function

	function private convert083to084 as extension::json (config as extension::json)
		dim buttons as extension::json = config.getProperty("buttons")
		dim newButtons as extension::json 
		newButtons.setJson("[]")

		for i = 0 to buttons.getLength() - 1 
			dim btn as extension::json = buttons.getIndexed(i)
			if btn.getProperty("onClick").hasProperty("listAction") then 
				if btn.getProperty("onClick").getProperty("listAction").getProperty("actionName") = "openJSONSublist" then 
					continue
				end if
			end if

			newButtons.push(btn)
		next

		config.setProperty("buttons", newButtons)
		config.setProperty("version", "0.8.4")
		convert083to084 = config
	end function

	function private convert082to083 as extension::json (config as extension::json)
		dim mappings as extension::json = config.getProperty("mappings")
		dim newMappings as extension::json 
		newMappings.setJson("[]")

		for i = 0 to mappings.getLength() - 1 
			dim mapping as extension::json = mappings.getIndexed(i)
			dim newMapping as extension::json
			newMapping.setJson("{}")
			if mapping.getProperty("tag") = "data" then 
				dim fullPath as extension::json 
				fullPath.setJson("[{\"tag\": \"object\", \"key\": \"" + mapping.getProperty("flattenedName") + "\"}]")
				newMapping.setProperty("fullPath", fullPath)

				if mapping.hasProperty("inList") then 
					newMapping.setProperty("inList", mapping.getProperty("inList"))
				end if

				if mapping.hasProperty("inDetailView") then 
					newMapping.setProperty("inDetailView", mapping.getProperty("inDetailView"))
				end if

				if mapping.hasProperty("readOnly") then 
					newMapping.setProperty("readOnly", mapping.getProperty("readOnly"))
				end if
				newMappings.push(newMapping)
			end if 
		next

		config.setProperty("mappings", newMappings)
		config.setProperty("version", "0.8.3")
		convert082to083 = config
	end function

	function private convert081to082 as extension::json (config as extension::json)
		dim mappings as extension::json = config.getProperty("mappings")
		dim newMappings as extension::json
		newMappings.setJson("[]")

		for i = 0 to mappings.getLength() - 1 
			newMappings.push(setDate081to082(mappings.getIndexed(i)))
		next

		config.setProperty("mappings", newMappings)
		config.setProperty("version", "0.8.2")
		convert081to082 = config
	end function

	function private setDate081to082 as extension::json (mapping as extension::json)
		if mapping.getProperty("tag") = "nested" then 
			dim inner as extension::json = mapping.getProperty("mapping")
			mapping.setProperty("mapping", setDate081to082(inner))
			setDate081to082 = mapping
		else if mapping.getProperty("tag") = "object" .or. mapping.getProperty("tag") = "array" then 
			dim inner as extension::json = mapping.getProperty("item")
			mapping.setProperty("item", setDate081to082(inner))
			setDate081to082 = mapping
		else 
			' No way to remove keys, so we just have to remap every key *except* serverDateFormat
			dim newMapping as extension::json 
			newMapping.setJson("{}")

			for i = 0 to mapping.getLength() - 1
				dim key as c = mapping.nameIndexed(i)
				if key == "serverDateFormat" then 
					self.MADE_CHANGES = .t.
				else 
					newMapping.setProperty(key, mapping.getProperty(key))
				end if
			next

			setDate081to082 = newMapping
		end if
	end function
	
	function private convert080to081 as extension::json (config as extension::json)
		dim buttons as extension::json = config.getProperty("buttons")
		dim newButtons as extension::json 
		newButtons.setJson("[]")
		
		for i = 0 to buttons.getLength() - 1 
			dim btn as extension::json = buttons.getIndexed(i)
			
			if btn.getProperty("onClick").hasProperty("listAction") then
				dim onClick as extension::json = btn.getProperty("onClick")
				dim action as extension::json = onClick.getProperty("listAction")
				
				if action.getProperty("actionName") = "openLinkedList"
					self.MADE_CHANGES = .t.
					dim newArr as extension::json
					newArr.setJson("[]")
					
					action.setProperty("linkedColumns", newArr)
				end if 
				
				onClick.setProperty("listAction", action)
				btn.setProperty("onClick", onClick)
			end if
			
			newButtons.push(btn)
		next
		
		config.setProperty("buttons", newButtons)
		config.setProperty("version", "0.8.1")
		convert080to081 = config
	end function
	
	function private convertUnversioned as extension::json (config as extension::json)
		config.setProperty("version", "0.8.0")
		MADE_CHANGES = .t.
		
		' Change: The 'jsonConfig' property on DataMappings went from JsonFieldTypeSchema to {editorType: string, definition: JsonFieldTypeSchema }
		dim newMappings as extension::json 
		newMappings.setJson("[]")
		
		for i = 0 to config.getProperty("mappings").getLength() - 1
			dim mapping as extension::json = config.getProperty("mappings").getIndexed(i)
			newMappings.push(convertUnversionedMapping(mapping))
		next
		
		config.setProperty("mappings", newMappings)
		
		convertUnversioned = config
	end function
	
	function private convertUnversionedMapping as extension::json (mapping as extension::json)
		dim tag as c = mapping.getProperty("tag")
		if tag = "data" then 
			if mapping.hasProperty("jsonConfig") then
				MADE_CHANGES = .t.
				
				dim oldConfig as extension::json = mapping.getProperty("jsonConfig")
				dim newConfig as extension::json 
				newConfig.setJson("{}")
				
				newConfig.setProperty("editorType", "form")
				newConfig.setProperty("definition", oldConfig)
				mapping.setProperty("jsonConfig", newConfig)
			end if
		else if tag = "nested"
			mapping.setProperty("mapping", convertUnversionedMapping(mapping.getProperty("mapping")))
		else if tag = "object" .or. tag = "array"
			mapping.setProperty("item", convertUnversionedMapping(mapping.getProperty("item")))
		end if
		
		convertUnversionedMapping = mapping
	end function
	
end class

